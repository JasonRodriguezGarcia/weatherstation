(DATOS DE PAGINA WEB) (AL FINAL EST√Å EL C√ìDIGO FINAL)
Home
Blog
Projects
Homekit
Software
About me
Contact
Search
GUIDE TO THE HWFS-1 ANEMOMETER
Accessories, Blog / June 8, 2025
Measuring wind speed is essential for weather stations, agricultural monitoring, HVAC automation, and safety systems. The HWFS-1 Anemometer is a cost-effective, analog-output wind speed sensor, ideal for both DIY and industrial environments. In this guide, you‚Äôll learn everything about the voltage-type HWFS-1 ‚Äî its principle, wiring, and how to use it effectively with microcontrollers.

What is the HWFS-1 Anemometer?
The HWFS-1 is a mechanical cup-style wind speed sensor with an integrated voltage generator. As the wind rotates the 3-cup rotor, the internal generator produces a voltage signal proportional to wind speed ‚Äî no external power supply is required.


Key Features
Model: HWFS-1
Type: Analog cup-type anemometer
Output: Voltage (0‚Äì2V typical, max 4V)
Power: Passive (no external power needed)
Wiring: 2 wires (Signal + Ground)
Material: ABS plastic, weather-resistant
Max Wind Speed: 200 KM/h
Recommended Range: < 100 KM/h
Installation: Bolt-through base, 3 √ó 6mm holes at 120¬∞
How It Works
When wind blows, the cups rotate and an internal electromagnetic generator produces a voltage. The output voltage increases linearly with wind speed:

0V ‚Üí no wind
2V ‚Üí ~100 KM/h
4V (max) ‚Üí ~200 KM/h (not recommended for continuous use)
HWFS-1 Wiring
    Wire	Function
    Black	GND (Ground)
    Black with Stripe	Signal (Voltage out, 0‚Äì2V typical)
Connect the signal wire to an ADC (Analog-to-Digital Converter) pin on your microcontroller (e.g., ESP32, Arduino) and the black wire to GND.

Note: There is no polarity, but consistency is best practice.

Using the HWFS-1 with a Microcontroller
Example Wiring (ESP32)
HWFS-1 Wire	ESP32 Pin
Black with stripe	GPIO 34 (ADC)
Solid black	GND

Sample Arduino Code (Analog Reading)
#define WIND_SENSOR_PIN 34

void setup() {
  Serial.begin(115200);
}

void loop() {
  int analogValue = analogRead(WIND_SENSOR_PIN); // 0‚Äì4095 on ESP32
  float voltage = analogValue * 3.3 / 4095.0;     // Convert to volts
  float windSpeedMS = voltage * 14.0;             // Wind speed in m/s
  float windSpeedKMH = voltage * 50.0;            // Wind speed in km/h

  Serial.print("Wind Speed: ");
  Serial.print(windSpeedMS);
  Serial.print(" m/s | ");
  Serial.print(windSpeedKMH);
  Serial.println(" km/h");

  delay(1000);
}

C√≥digo adaptado para un ESP8266 nodemcu
// √önico pin anal√≥gico del ESP8266
#define WIND_SENSOR_PIN A0   

void setup() {
  Serial.begin(115200);
}

void loop() {
  int analogValue = analogRead(WIND_SENSOR_PIN); // 0‚Äì1023 en ESP8266
  float voltage = analogValue * 3.3 / 1023.0;     // Convertir a voltios reales del sensor

  // Ajusta estas f√≥rmulas seg√∫n tu sensor si es necesario
  float windSpeedMS = voltage * 14.0;             // Velocidad en m/s
  float windSpeedKMH = voltage * 50.0;            // Velocidad en km/h

  Serial.print("Wind Speed: ");
  Serial.print(windSpeedMS);
  Serial.print(" m/s | ");
  Serial.print(windSpeedKMH);
  Serial.println(" km/h");

  delay(1000);
}

Calibration Formula
You can estimate wind speed directly using these formulas:

Wind speed (km/h) = Voltage (V) √ó 50
Wind speed (m/s) = Voltage (V) √ó 14
 Example: If the voltage is 0.5V, then:

Wind speed ‚âà 25 km/h
Wind speed ‚âà 7 m/s
Practical Applications
Weather Stations: Monitor outdoor wind conditions
HVAC Automation: Adjust systems based on outside airflow
Agriculture: Control irrigation and ventilation based on wind
Wind-Triggered Systems: LED beacons, safety alerts, etc.
Best Practices
Mount horizontally at an open, unobstructed location
Avoid metallic interference or lightning-prone spots
Use waterproof enclosures for electronics
Shield analog cable if longer than 3 meters
Use a stable analog reference voltage for accuracy
Conclusion: Wind Speed Made Simple
The voltage-type HWFS-1 Anemometer is a reliable, easy-to-use analog wind speed sensor ideal for embedded systems. Its passive design requires no power supply, and it integrates seamlessly with ADC-enabled microcontrollers like the ESP32 and Arduino. With linear voltage output and simple formulas, it‚Äôs a perfect sensor for anyone needing real-time wind data.

Happy Measuring!

‚Üê Previous Post
Next Post ‚Üí
SUPPORTER OF



SPONSORED BY

COLLABORATED WITH


FEATURED ON

StudioPieters.nl is a non-commercial, hobbyist website.
No personal data is stored by us.
All information is provided as-is, without warranty.
Use is at your own risk. ¬© StudioPieters.nl 2025
Read the full Privacy Policy and Disclaimer

Copyright ¬© 2025 |  StudioPieters¬Æ | All rights reserved.

Build by Achim Pieters

Scroll to Top
*******************
*******************
*******************

m√°s info:

Tienes un anem√≥metro HWFS-1 de salida anal√≥gica (0‚Äì2‚ÄØV t√≠pico) y quieres conectarlo a un Amica ESP8266 NodeMCU. Esto implica dos aspectos clave: el nivel de voltaje y la adaptaci√≥n del c√≥digo Arduino.

1Ô∏è‚É£ Voltaje y compatibilidad con ESP8266

El ESP8266 NodeMCU tiene un ADC de 10 bits que mide entre 0‚Äì3.3‚ÄØV, conectado al pin A0.
Tu anem√≥metro produce 0‚Äì2‚ÄØV t√≠picos, con picos hasta 4‚ÄØV (no recomendados).

Como 2‚ÄØV < 3.3‚ÄØV, no necesitas divisor de tensi√≥n para el rango normal (<100‚ÄØkm/h).

Si quieres medir picos hasta 4‚ÄØV, s√≠ necesitar√≠as un divisor de tensi√≥n, por ejemplo usando dos resistencias en 
serie (R1 y R2) para reducir a 3.3‚ÄØV m√°ximo:

ùëâùëúùë¢ùë°=ùëâùëñùëõ√ó   ùëÖ2
         --------
         ùëÖ1+ùëÖ2
Para 4‚ÄØV ‚Üí 3.3‚ÄØV, el factor es 0.825. Por ejemplo: R1 = 1kŒ©, R2 = 4.7kŒ©.

üí° Pero para uso t√≠pico (<100‚ÄØkm/h), puedes conectar directamente.

2Ô∏è‚É£ Cableado al ESP8266

GND (negro) ‚Üí GND del NodeMCU

Signal (negro con raya) ‚Üí A0 del NodeMCU

Nota: Solo hay un pin anal√≥gico en NodeMCU (A0), diferente del ESP32 que tiene varios (como el pin 34 de tu c√≥digo).

3Ô∏è‚É£ Adaptaci√≥n del c√≥digo

Tu c√≥digo de Arduino est√° escrito para ESP32 (analogRead devuelve 0‚Äì4095). En el ESP8266 NodeMCU:

analogRead(A0) devuelve un valor de 0‚Äì1023 (10 bits).

El pin es A0, no 34.

El voltaje m√°ximo es 3.3‚ÄØV.

Entonces el c√≥digo adaptado ser√≠a:

// Pin anal√≥gico del ESP8266
#define WIND_SENSOR_PIN A0  

void setup() {
  Serial.begin(115200);
}

void loop() {
  int analogValue = analogRead(WIND_SENSOR_PIN); // 0‚Äì1023
  float voltage = analogValue * 3.3 / 1023.0;     // Convertir a voltios
  float windSpeedMS = voltage * 14.0;             // Velocidad en m/s
  float windSpeedKMH = voltage * 50.0;            // Velocidad en km/h

  Serial.print("Wind Speed: ");
  Serial.print(windSpeedMS);
  Serial.print(" m/s | ");
  Serial.print(windSpeedKMH);
  Serial.println(" km/h");

  delay(1000);
}

4Ô∏è‚É£ Resumen r√°pido

Cableado: Negro ‚Üí GND, Negro con raya ‚Üí A0

Divisor de tensi√≥n: No necesario para <100‚ÄØkm/h

C√≥digo: Cambiar WIND_SENSOR_PIN a A0 y ajustar rango de analogRead de 0‚Äì4095 ‚Üí 0‚Äì1023

Voltaje: 0‚Äì2‚ÄØV t√≠pico ‚Üí 0‚Äì50‚ÄØkm/h (seg√∫n tus c√°lculos)

Si quieres, puedo hacerte un c√≥digo mejorado que promedie varias lecturas y suavice el ruido, porque los anem√≥metros anal√≥gicos suelen dar se√±ales un poco inestables. Esto te dar√° lecturas m√°s estables de viento.

¬øQuieres que haga eso?

T√∫ dijiste:
quiero ponerle un divisor de tensi√≥n, adecuar el c√≥digo acorde:
ChatGPT Plus

Perfecto. Vamos a hacer todo paso a paso: divisor de tensi√≥n para proteger el ESP8266 y c√≥digo adaptado.

1Ô∏è‚É£ Divisor de tensi√≥n

Tu anem√≥metro puede dar hasta 4‚ÄØV, y el A0 del ESP8266 soporta m√°ximo 3.3‚ÄØV.
Queremos reducir el voltaje a un factor seguro:

ùëâùëúùë¢ùë°=ùëâùëñùëõ√ó   ùëÖ2
        ----------
        ùëÖ1+ùëÖ2

Queremos 4‚ÄØV ‚Üí 3.3‚ÄØV

    ùëÖ2          3.3
---------= ------------ =0.825
 ùëÖ1+ùëÖ2           4

Ejemplo de resistencias:

R1 = 1‚ÄØkŒ©
R2 ‚âà 4.7‚ÄØkŒ©

Esto da:
            4.7
ùëâùëúùë¢ùë°=4√ó ---------- ‚âà 3.3
            1+4.7

‚úÖ Esto protege tu ESP8266 incluso con r√°fagas de viento altas.

Conexi√≥n del divisor:
Anem√≥metro GND  ------------------- GND
Anem√≥metro Signal ---- R1 ----+---- A0 del ESP8266
                               |
                              R2
                               |
                              GND


GND del anem√≥metro ‚Üí GND del NodeMCU

Signal del anem√≥metro ‚Üí R1 del divisor

Nodo entre R1 y R2 ‚Üí A0

R2 ‚Üí GND

**************************
2Ô∏è‚É£ C√≥digo adaptado USADO FINALMENTE************
**************************
Como ahora hay un divisor de tensi√≥n que reduce el voltaje por factor 0.825, hay que corregir el c√°lculo de velocidad.

// C√≥digo para anem√≥metro HWFS-1 

// √önico pin anal√≥gico del ESP8266
#define WIND_SENSOR_PIN A0   

// Evitamos la posibilidad de que suba a 4V, m√°x 3.3v en A0
const float DIVIDER_FACTOR = 0.825; 

// Offset medido con el sensor quieto y conectado al ESP
// (al estar quieto sin moverse hay veces que se muestra un valor residual)
const float OFFSET_VOLTAGE = 0.039;

void setup() {
  Serial.begin(9600);
}

void loop() {

  // -------- PROMEDIO EN LAS LECTURAS ----------
  int analogValue = 0;
  for (int i = 0; i < 10; i++) {
    analogValue += analogRead(WIND_SENSOR_PIN);
    delay(2);
  }
  analogValue /= 10;

  // -------- VOLTAJE ----------
  float voltage = analogValue * 3.3 / 1023.0;
  voltage = voltage / DIVIDER_FACTOR;

  // -------- RESTAR OFFSET ----------
  voltage -= OFFSET_VOLTAGE;
  if (voltage < 0.0) voltage = 0.0;

  // -------- VELOCIDAD ----------
  float windSpeedMS = voltage * 14.0;
  float windSpeedKMH = voltage * 50.0;

  // -------- ELIMINAR VELOCIDAD RESIDUAL (A VECES MUESTRA 0.01KM/H) POR ----------
  //      redondeos internos del float
  //      multiplicaci√≥n por 50.0
  //      ruido m√≠nimo de ¬±1 en la lectura ADC
  if (windSpeedMS < 0.02) windSpeedMS = 0.0;
  if (windSpeedKMH < 0.05) windSpeedKMH = 0.0;

  // -------- SALIDA ----------
  Serial.print("Voltaje ajustado: ");
  Serial.print(voltage, 3);
  Serial.print(" V | Velocidad viento: ");
  Serial.print(windSpeedMS, 2);
  Serial.print(" m/s | ");
  Serial.print(windSpeedKMH, 2);
  Serial.println(" km/h");

  delay(500);
}
‚úÖ Resumen

Divisor de tensi√≥n: R1 = 1‚ÄØkŒ©, R2 = 4.7‚ÄØkŒ©

Pin: A0

Factor de correcci√≥n: 0.825

C√≥digo: Ajusta la lectura del ADC multiplicando por 3.3/1023 y luego dividiendo por 0.825

Esto te permite leer hasta 4‚ÄØV sin riesgo para tu NodeMCU y calcular correctamente la velocidad del viento.

Si quieres, puedo hacer una versi√≥n del c√≥digo que promedie 10‚Äì20 lecturas para que el valor de viento sea m√°s estable, porque las se√±ales del anem√≥metro pueden ser muy ‚Äútemblorosas‚Äù.

Conexi√≥n paso a paso
    Conecta la tierra del anem√≥metro:
        Cable negro del anem√≥metro ‚Üí GND del NodeMCU
    Conecta la se√±al a trav√©s de R1:
        Cable negro con raya (Signal) del anem√≥metro ‚Üí un extremo de R1
    Conecta el nodo al pin A0:
        Conecta el otro extremo de R1 a un nodo de conexi√≥n.
        Desde este nodo ‚Üí pin A0 del NodeMCU
    Agrega R2 para completar el divisor:
        Desde el mismo nodo ‚Üí conecta R2 hacia GND del NodeMCU

